const fs = require('fs');
const path = require('path');

// Language codes and their names
const languages = {
  cn: { 
    code: 'cn', 
    name: 'Chinese', 
    notice: '> **注意**: 此页面尚未翻译成中文。以下内容为英文原版。',
    metaTag: '{/* AUTO-GENERATED-CONTENT:START (ENGLISH-COPY) */}'
  },
  jp: { 
    code: 'jp', 
    name: 'Japanese', 
    notice: '> **注意**: このページはまだ日本語に翻訳されていません。以下は英語の原文です。',
    metaTag: '{/* AUTO-GENERATED-CONTENT:START (ENGLISH-COPY) */}'
  },
  ko: { 
    code: 'ko', 
    name: 'Korean', 
    notice: '> **참고**: 이 페이지는 아직 한국어로 번역되지 않았습니다. 아래는 영어 원문입니다.',
    metaTag: '{/* AUTO-GENERATED-CONTENT:START (ENGLISH-COPY) */}'
  }
};

// Directories to copy (excluding 'learn' which is already translated)
const directoriesToCopy = ['build', 'sdk', 'client', 'guides', 'get-involved'];

// Function to get all files in a directory recursively
function getAllFiles(dirPath, arrayOfFiles = []) {
  const files = fs.readdirSync(dirPath);

  files.forEach(file => {
    const filePath = path.join(dirPath, file);
    if (fs.statSync(filePath).isDirectory()) {
      arrayOfFiles = getAllFiles(filePath, arrayOfFiles);
    } else if (file.endsWith('.mdx') || file.endsWith('.md')) {
      arrayOfFiles.push(filePath);
    }
  });

  return arrayOfFiles;
}

// Function to add translation notice to content
function addTranslationNotice(content, language) {
  // Check if the file has frontmatter
  const frontmatterMatch = content.match(/^(---\n[\s\S]*?\n---\n)/);
  
  if (frontmatterMatch) {
    // Insert metadata tag and notice after frontmatter
    const frontmatter = frontmatterMatch[0];
    const restOfContent = content.substring(frontmatter.length);
    return `${frontmatter}\n${language.metaTag}\n${language.notice}\n${restOfContent}`;
  } else {
    // If no frontmatter, insert at the beginning
    return `${language.metaTag}\n${language.notice}\n\n${content}`;
  }
}

// Function to check if a file is auto-generated
function isAutoGenerated(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    return content.startsWith('{/* AUTO-GENERATED-CONTENT:START (ENGLISH-COPY) */}');
  } catch (e) {
    return false;
  }
}

// Function to update internal links to use language prefix
function updateInternalLinks(content, langCode) {
  // Update links that start with /build, /sdk, etc.
  directoriesToCopy.forEach(dir => {
    const regex = new RegExp(`(\\[.*?\\]\\()(/${dir}/[^)]+\\))`, 'g');
    content = content.replace(regex, `$1/${langCode}$2`);
  });
  
  // Also update links to learn section to use language prefix
  content = content.replace(/(\[.*?\]\()(\/learn\/[^)]+\))/g, `$1/${langCode}$2`);
  
  return content;
}

// Main function
async function copyEnglishToLanguages() {
  const rootPath = path.join(__dirname, '..');
  const summary = {
    cn: { copied: 0, skipped: 0, updated: 0 },
    jp: { copied: 0, skipped: 0, updated: 0 },
    ko: { copied: 0, skipped: 0, updated: 0 }
  };
  
  for (const [langCode, langInfo] of Object.entries(languages)) {
    console.log(`\nProcessing ${langInfo.name} (${langCode})...`);
    
    for (const dir of directoriesToCopy) {
      const sourceDir = path.join(rootPath, dir);
      const targetDir = path.join(rootPath, langCode, dir);
      
      if (!fs.existsSync(sourceDir)) {
        console.log(`  Skipping ${dir} - source directory not found`);
        continue;
      }
      
      // Create target directory if it doesn't exist
      fs.mkdirSync(targetDir, { recursive: true });
      
      // Get all markdown files in source directory
      const files = getAllFiles(sourceDir);
      
      console.log(`  Copying ${files.length} files from ${dir}...`);
      
      files.forEach(filePath => {
        const relativePath = path.relative(sourceDir, filePath);
        const targetPath = path.join(targetDir, relativePath);
        
        // Check if file already exists
        let isUpdate = false;
        if (fs.existsSync(targetPath)) {
          // If it's auto-generated, we can update it
          if (isAutoGenerated(targetPath)) {
            console.log(`    Updating ${relativePath} - auto-generated content`);
            isUpdate = true;
            // Continue with the update
          } else {
            // It's a real translation, skip it
            console.log(`    Skipping ${relativePath} - manually translated`);
            summary[langCode].skipped++;
            return;
          }
        }
        
        // Create target directory structure
        fs.mkdirSync(path.dirname(targetPath), { recursive: true });
        
        // Read source file
        let content = fs.readFileSync(filePath, 'utf8');
        
        // Add translation notice
        content = addTranslationNotice(content, langInfo);
        
        // Update internal links
        content = updateInternalLinks(content, langCode);
        
        // Write to target
        fs.writeFileSync(targetPath, content);
        
        // Update appropriate counter
        if (isUpdate) {
          summary[langCode].updated++;
        } else {
          summary[langCode].copied++;
        }
      });
    }
    
    // Copy any JSON files (like navigation.json) if they exist in those directories
    for (const dir of directoriesToCopy) {
      const sourceDir = path.join(rootPath, dir);
      const targetDir = path.join(rootPath, langCode, dir);
      
      if (fs.existsSync(sourceDir)) {
        const jsonFiles = fs.readdirSync(sourceDir).filter(f => f.endsWith('.json'));
        jsonFiles.forEach(file => {
          const sourcePath = path.join(sourceDir, file);
          const targetPath = path.join(targetDir, file);
          
          if (fs.statSync(sourcePath).isFile()) {
            // For navigation.json files, we might need to update paths
            if (file === 'navigation.json') {
              let content = fs.readFileSync(sourcePath, 'utf8');
              let json = JSON.parse(content);
              
              // Update paths in navigation to include language prefix
              const updatePaths = (obj) => {
                if (typeof obj === 'string') {
                  return `${langCode}/${obj}`;
                } else if (Array.isArray(obj)) {
                  return obj.map(updatePaths);
                } else if (obj && typeof obj === 'object') {
                  const result = {};
                  for (const [key, value] of Object.entries(obj)) {
                    if (key === 'pages' || key === 'path') {
                      result[key] = updatePaths(value);
                    } else {
                      result[key] = updatePaths(value);
                    }
                  }
                  return result;
                }
                return obj;
              };
              
              json = updatePaths(json);
              fs.writeFileSync(targetPath, JSON.stringify(json, null, 2));
            } else {
              // Copy other JSON files as-is
              fs.copyFileSync(sourcePath, targetPath);
            }
          }
        });
      }
    }
    
    console.log(`  Completed ${langInfo.name}`);
  }
  
  console.log('\nAll languages processed successfully!');
  
  // Print summary
  console.log('\nSummary:');
  for (const [langCode, stats] of Object.entries(summary)) {
    console.log(`${languages[langCode].name} (${langCode}):`);
    console.log(`  - New files copied: ${stats.copied}`);
    console.log(`  - Files updated: ${stats.updated}`);
    console.log(`  - Files skipped (manually translated): ${stats.skipped}`);
    console.log(`  - Total affected: ${stats.copied + stats.updated}`);
  }
}

// Run the script
copyEnglishToLanguages().catch(console.error);