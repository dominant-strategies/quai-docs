---
title: 使用 SolidityX 部署
description: 在 Quai Network 上部署和链接多链智能合约的指南。
---

## 介绍

在本文中，我们将详细介绍如何在 Quai Network 的 2 个不同分片上部署、链接和交互多链智能合约。这种方法可以扩展到在所有 9 个分片上部署无需信任的跨链合约。

我们将使用 [QRC721 代币](https://github.com/dominant-strategies/SolidityX-Contracts/blob/main/QRC721X.sol) 的基本实现（[ERC721 标准](https://eips.ethereum.org/EIPS/eip-721) 的改编版本）来展示本教程的跨链合约。

## 前提条件

要在 Quai 上部署多链智能合约，我们需要一些工具包和依赖项。以下是我们将使用的所有依赖项概述：

|                                                                               |                                                                        |
| ----------------------------------------------------------------------------- | ---------------------------------------------------------------------- |
| [**NodeJS**](https://nodejs.org/en/download/)                                 | Javascript 运行时环境。请使用 LTS 版本。                               |
| [**hardhat-example**](https://github.com/dominant-strategies/hardhat-example) | 包含 Quai Network 示例合约和部署脚本的 Hardhat 项目。                  |
| [**Quais.js**](https://www.npmjs.com/package/quais)                           | 用于与 Quai Network 交互的 JavaScript 库。                            |
| [**quai-hardhat-plugin**](https://www.npmjs.com/package/quai-hardhat-plugin)  | 为 Hardhat 构建的插件，提供 SolidityX 编译器支持。                     |

## 环境设置

### 依赖项

首先克隆 `hardhat-example` 仓库，导航到本教程将使用的 `SolidityX/` 目录，并通过 `npm` 安装依赖项。

```bash
git clone https://github.com/dominant-strategies/hardhat-example.git
cd hardhat-example/SolidityX
npm install
```

<Tip>
	如果您已经为[单链部署教程](/cn/guides/development/solidity)克隆了 `hardhat-example` 仓库，可以跳过克隆步骤。只需导航到 `SolidityX/` 目录并运行 `npm install`。
</Tip>

### 智能合约

`SolidityX` 目录包含 2 个示例合约：`contracts/` 目录中的 `QRC20.sol` 和 `QRC721.sol`。这两个包含的合约都是现有代币标准的初始 SolidityX/跨链实现。合约源代码可以在 [SolidityX-Contracts 仓库](https://github.com/dominant-strategies/SolidityX-Contracts) 中找到。

如上所述，我们将部署 [QRC721 智能合约](https://github.com/dominant-strategies/SolidityX-Contracts/blob/main/QRC721X.sol)。在配置和部署 QRC721 之前，我们建议熟悉[合约规范](https://github.com/dominant-strategies/SolidityX-Contracts/blob/main/QRC721X.sol)。

### 环境变量

我们在 `hardhat-example` 仓库的根目录中包含了一个示例 [.env.dist](https://github.com/dominant-strategies/hardhat-example/blob/main/.env.dist) 环境文件，用于安全地保存代币详情、私钥和 RPC URL。

<Note>
`.env.dist` 文件是一个模板文件，不应直接使用。您应该使用以下命令将 `.env.dist` 文件复制到仓库根目录的新 `.env` 文件：

此文件位于 `hardhat-example` 仓库的根目录，作为 `Solidity` 和 `SolidityX` 目录的配置文件。

</Note>

使用以下命令将根目录中的 `.env.dist` 文件复制到仓库根目录的新 `.env` 文件：

```bash
cp ../.env.dist ../.env
```

打开 `.env` 文件并添加您的私钥、RPC URL 和要部署的合约的代币参数。`.env` 文件应如下所示：

```bash .env
# 每个部署地址的唯一私钥
CYPRUS1_PK="0x3700000000000000000000000000000000000000000000000000000000000000" # 以 0x00 开头的公钥
CYPRUS2_PK="0x9400000000000000000000000000000000000000000000000000000000000000" # 以 0x01 开头的公钥
...更多私钥

# 链 ID（本地：1337，测试网和开发网：9000）
CHAIN_ID="9000"

# RPC 端点
RPC_URL="https://rpc.quai.network"
...更多 rpc url

# 代币参数
...更多代币参数
```

<Note>
	`PK` 值必须都是唯一地址的私钥，并对应于区域名称，即您的 `CYPRUS1_PK` 应该是您的 Cyprus1 地址的私钥。
</Note>

有关 RPC 端点的更多信息，请参阅 **本地节点** 的[本地网络规范](/cn/build/networks#local-network)部分和 **远程节点** 的[开发网规范](/cn/build/networks#devnet)部分。

`hardhat-example` 仓库使用 [Quais SDK](/cn/sdk/introduction) 仅使用一个 RPC URL 配置网络连接。要了解有关 SDK 如何配置网络提供者的更多信息，请访问 [SDK 提供者示例](/cn/sdk/static/provider)部分。

填写私钥和 RPC URL 后，我们现在可以在 `hardhat.config.js` 中安全地使用它们了。

### Hardhat 配置

Hardhat 使用 `hardhat.config.js` 来配置智能合约部署。配置文件允许您定义部署网络、任务、编译器等。`hardhat-example/SolidityX` 包含一个预构建的 `hardhat.config.js` 文件，其中包含用于在 Quai 上编译、部署、验证 SolidityX 智能合约的配置。

下面的配置文件与用于基本 Solidity 合约部署的 `hardhat.config.js` 文件有**两个主要区别**：

- 导入 `quai-hardhat-plugin` 来**处理 SolidityX 编译器下载**
- 包含可选的 `solidityx` 对象以指定本地构建的 SolidityX 编译器（_如果您不想使用插件下载编译器_）

<Accordion title="示例 hardhat 配置文件" icon="file" iconType="solid">
  此示例配置文件作为 `hardhat-example` 仓库的一部分提供。
  ```javascript hardhat.config.js
  /**
   * @type import('hardhat/config').HardhatUserConfig
   */

require("@nomicfoundation/hardhat-toolbox");
require('quai-hardhat-plugin');
require("@quai/hardhat-deploy-metadata");
const dotenv = require("dotenv");
dotenv.config({ path: "../.env" });

const rpcUrl = process.env.RPC_URL;
const chainId = Number(process.env.CHAIN_ID);

module.exports = {
defaultNetwork: "cyprus1",
networks: {
cyprus1: {
url: rpcUrl,
accounts: [process.env.CYPRUS1_PK],
chainId: chainId,
},
cyprus2: {
url: rpcUrl,
accounts: [process.env.CYPRUS2_PK],
chainId: chainId,
},
...更多网络
},

    // 本地构建的 solcx 的可选 solidityx 配置，如果未指定将下载 solcx

    // macOS 本地 solc 的常见路径（如果使用 macOS，请取消注释并编辑路径）
    // solidityx: { compilerPath: '/usr/local/bin/solc' },
    // Linux 本地 solc 的常见路径（如果使用 Linux，请取消注释并编辑路径）
    // solidityx: { compilerPath: '/path/to/SolidityX/build/solc/solc' },


    solidity: {
      version: "0.8.0",
      settings: {
        optimizer: {
          enabled: true,
          runs: 1000,
        },
      },
    },

};

````
  <Warning>
    Golden Age 开发网目前支持 Cyprus 1 和 2。当前网络配置中所有其他分片都未运行。
  </Warning>
  在配置文件中，您可以找到以下部署和验证定义：

  - `cyprus1`
  - `cyprus2`
  - `cyprus3`
  - `paxos1`
  - `paxos2`
  - `paxos3`
  - `hydra1`
  - `hydra2`
  - `hydra3`
</Accordion>

部署或验证合约时，`hardhat.config.js` 将从 `.env` 文件中提取您的私钥和 RPC URL，并使用它们来部署和验证您的合约。

### SolidityX 编译器

为了能够正确编译和部署 SolidityX 合约，我们需要 [SolidityX](https://github.com/dominant-strategies/SolidityX)。有两种方法可以安装 SolidityX 编译器以与 Hardhat 一起使用：

- 通过 [quai-hardhat-plugin](https://www.npmjs.com/package/quai-hardhat-plugin) 安装 SolidityX 编译器（**推荐**）
- 从源代码安装和构建 SolidityX 编译器

<Tabs>
  <Tab title="通过插件安装">
    如上所述，`hardhat.config.js` 文件已经包含了 `quai-hardhat-plugin` 来处理 SolidityX 编译器下载。如果您已经按照上述步骤操作，您已经设置好使用插件下载 SolidityX 编译器了。
  </Tab>
  <Tab title="从源代码安装">
    <Warning>
      从源代码构建编译器并导入仍然需要在 `hardhat.config.js` 文件中安装和配置 `quai-hardhat-plugin`。
    </Warning>

    访问 [SolidityX 仓库](https://github.com/dominant-strategies/SolidityX) 了解如何为您的特定操作系统克隆和构建 SolidityX 编译器的说明。

    构建 SolidityX 编译器后，您需要将 `solc` 二进制文件的路径添加到 `hardhat.config.js` 中 `solidityX` 对象的 `compilerPath` 变量中。该文件已经包含 MacOS 和 Linux 的常见路径作为注释。

  </Tab>
</Tabs>

## 部署

<Steps>
  <Step title="使用 SolidityX 编译">
    使用 Hardhat 进行 SolidityX 合约编译很简单，可以在 CLI 中使用 `npx` 完成。

    使用以下命令编译 `contracts/` 目录中的所有合约：

    ```bash
    npx hardhat compile
````

    应该输出类似这样的内容：

    ```bash
    Info Using SolidityX at: /Users/user/hardhat-example/SolidityX/solc
    Warning: This is a pre-release compiler version, please do not use it in production.

    Compiled 2 Solidity files successfully (evm target: istanbul).

````
  </Step>
  <Step title="配置部署脚本">
    在 `scripts/` 目录中，您会找到 QRC20 和 QRC721 合约的部署脚本：`deployQRC20.js` 和 `deployQRC721.js`。在本教程中，我们将使用 QRC721 合约。

    `deployQRC721.js` 脚本通过从 `hardhat.config.js` 中提取您指定的网络/账户配置和从仓库根目录的 `.env` 文件中指定的 QRC721 参数来工作，并使用它们来部署您的合约。

    代币参数通过 `tokenArgs` 数组使用：

    ```javascript
    const tokenArgs = [process.env.QRC721_NAME, process.env.QRC721_SYMBOL, process.env.QRC721_BASE_URI]
````

    您指定的网络配置在 `provider` 和 `wallet` 变量中与编译的合约 ABI 和字节码结合使用，以创建新的合约实例：

    ```javascript
    const provider = new quais.JsonRpcProvider(hre.network.config.url, undefined, { usePathing: true })
    const wallet = new quais.Wallet(hre.network.config.accounts[0], provider)
    const QRC721 = new quais.ContractFactory(QRC721Json.abi, QRC721Json.bytecode, wallet)

````

    我们将在下一步中使用这些概念来正确修改代币参数和网络规范以部署我们的合约。

  </Step>
  <Step title="部署合约">
    在本教程中，我们将在两个不同的链上部署**两个实例**的 QRC721 合约。您可以将此处使用的方法扩展到 Quai Network 内任何分片组合上部署和链接合约。

    我们将在 Cyprus-1 链上部署第一个 QRC721 合约。为此，我们将在部署命令中传递 `cyprus1` 作为网络标志，如下所示：

    ```bash
    npx hardhat run scripts/deployQRC721.js --network cyprus1
````

    运行此命令应该输出：

    ```bash
    Transaction broadcasted: 0x018100ff42c92c99ddfe8f577ce63743769ae2daf46ad2032eec3bc3f803961d
    Contract deployed to: 0x00735E9B2c731Fd3eCC8129a3653ACb99dF969cC

````

    现在，我们可以将相同的 QRC721 合约部署到 Quai 内的另一个分片，如 Cyprus-2。像之前一样，您将在部署命令中传递 `cyprus2` 作为网络标志。

    <Warning>
      部署 QRC721 时，我们建议为每条链更改 `baseURI` 变量以防止重复铸造，或者额外修改 QRC721 合约以处理不同分片上的铸造。此变量可以在仓库根目录的 `.env` 文件中更改。
    </Warning>

    ```bash
    npx hardhat run scripts/deployQRC721.js --network cyprus2
````

    这应该再次输出类似这样的内容：

    ```bash
    Transaction broadcasted: 0x01b40095e3d8e9d498a1ee8eb0500b832a3c98abf9b787fcc63a91c37585fbe7
    Contract deployed to: 0x0172F38EC31f58B1419E2CcE2B05B095625218ea

````

    我们现在已经将测试 QRC721 合约部署到 Cyprus-1 和 Cyprus-2 链上了！

    <Note>确保保存这两个合约地址，我们在下一节中需要它们。</Note>

  </Step>
</Steps>

## 链接姊妹合约

要完成我们的跨链 NFT 部署，我们需要链接两个已部署的合约。

_"链接"_ 两个 QRC721 合约可以通过将我们的 QRC721 的已部署合约地址添加到每个合约内的批准合约数组来完成。这可以使用 `AddApprovedAddresses` 方法完成。它接受 2 个数组作为参数：链索引和批准的地址。

下面显示的 `AddApprovedAddresses` 方法可用于向 QRC721 或 QRC20 合约的 `approvedAddresses` 数组添加少至 1 个或多至 8 个姊妹合约。

```solidity QRC721.sol
  function AddApprovedAddresses(uint8[] calldata chain, address[] calldata addr) external {
    require(msg.sender == _deployer, "Sender is not deployer");
    require(chain.length == addr.length, "chain and address arrays must be the same length");
    for(uint8 i = 0; i < chain.length; i++) {
        require(chain[i] < 9, "Max 9 zones");
        require(ApprovedAddresses[chain[i]] == address(0), "The approved address for this zone already exists");
        ApprovedAddresses[chain[i]] = addr[i];
    }
  }
````

一旦姊妹合约地址被添加到每个 QRC721 合约的各自 `ApprovedAddresses` 中，`transferFrom` 方法的跨链功能就可以使用了，这允许任何拥有该系列代币的人在合约部署到的分片之间无需信任地发送他们的代币。

#### 合约链接脚本

要链接姊妹合约，我们将利用 `quais.js` 和我们在部署脚本中使用的一些 Hardhat 运行时环境。首先在脚本目录中创建另一个名为 `addApprovedAddresses.js` 的文件。

```bash
touch scripts/addApprovedAddresses.js
```

然后，将以下代码粘贴到 `addApprovedAddresses.js` 中：

```javascript addApprovedAddresses.js
const quais = require('quais')
const QRC721 = require('../artifacts/contracts/QRC721.sol/QRC721.json')

async function AddApprovedQRC721Addresses() {
	const provider = new quais.JsonRpcProvider(hre.network.config.url, undefined, { usePathing: true })
	const privateKey = hre.network.config.accounts[0]
	const wallet = new quais.Wallet(privateKey, provider)
	const contractAddress = '要更改地址数组的合约地址' // 要添加批准地址的合约地址
	const qrc721 = new quais.Contract(contractAddress, QRC721.abi, wallet)
	try {
		const tx = await qrc721.AddApprovedAddresses(
			[0, 1], // 链索引（cyprus1 是 0，cyprus2 是 1，等等）
			['0x00...', '0x01....'] // 合约地址（必须与链索引的顺序相同）
		)
		const txRecipt = await tx.wait()
		console.log('Transaction mined with hash', txReceipt.hash)
	} catch (error) {
		console.error('Error sending transaction:', error)
	}
}

AddApprovedQRC721Addresses()
	.then(() => process.exit(0))
	.catch((error) => {
		console.error(error)
		process.exit(1)
	})
```

`addApprovedAddresses.js` 脚本使用 `QRC721.sol` ABI 来组成并发送一个交易，将新地址插入到任何已部署的 QRC721 合约的 `approvedAddresses` 数组中。

<Accordion title='链接脚本如何工作'>
	1. 首先，使用我们从 Hardhat 指定的网络配置创建 quais `provider` 2. 使用我们的 `provider` 和从 Hardhat 的密钥配置创建 quais `wallet` 3. 使用导入的 `QRC721.sol` ABI、合约地址和 `wallet` 定义我们要添加批准地址的合约 4. 使用输入组成 `addApprovedAddresses` 交易 - `chainIndex` 数组：对应于我们要添加到 `approvedAddresses` 的地址的整数链索引 - `address` 数组：我们要添加到 `approvedAddresses` 的合约地址 5. 发送交易并等待包含在区块中。
</Accordion>

将链接脚本的代码粘贴到 `addApprovedAddresses.js` 文件后，我们就可以开始链接我们的姊妹合约了。

<Steps>
  <Step title="构建链接交易">
    现在我们已经设置了脚本，**我们准备链接我们的两个已部署合约**。

    首先获取我们在[部署部分](#deploy-your-contracts)中部署的两个合约的地址。

    ```bash
    Cyprus 1 合约地址：0x00735E9B2c731Fd3eCC8129a3653ACb99dF969cC
    Cyprus 2 合约地址：0x0172F38EC31f58B1419E2CcE2B05B095625218ea

````

    我们将使用这些合约地址来构建传递给 `addApprovedAddresses` 方法的交易数据。

    <Tip>
      **您可以将相同的交易数据传递给您想要链接的每个合约**，因为 `addApprovedAddresses` 方法**可以接受并处理自己的合约地址作为参数**。这消除了为您想要链接的每个合约更改交易数据的需要。
    </Tip>

    我们需要传递给 `addApprovedAddresses` 方法的交易数据是**（注意数组的顺序）**：

    - `chainIndex` 数组：`[0, 1]`
    - `address` 数组：`['0x00735E9B2c731Fd3eCC8129a3653ACb99dF969cC', '0x0172F38EC31f58B1419E2CcE2B05B095625218ea']`

    构建的交易应该类似于这样：

    ```javascript
    const tx = await qrc721.AddApprovedAddress(
      [0, 1], // 链索引 [cyprus1, cyprus2]
      ['0x00735E9B2c731Fd3eCC8129a3653ACb99dF969cC', '0x0172F38EC31f58B1419E2CcE2B05B095625218ea'] // 合约地址 [cyprus1, cyprus2]
    )
    ```

    <Note>
      您可以通过向数组添加额外的链索引和合约地址来扩展此交易数据结构以链接任意数量的合约。**始终确保向数组添加相同数量的链索引和合约地址，并且顺序匹配**。
    </Note>

  </Step>
  <Step title="发送链接交易">
    首先，我们将向我们的 Cyprus 1 合约发送链接交易。为此，首先在 `addApprovedAddresses.js` 脚本中将 `contractAddress` 变量更改为我们的 **Cyprus 1 合约地址**：

    ```javascript
    const contractAddress = '0x00735E9B2c731Fd3eCC8129a3653ACb99dF969cC'
````

    现在，我们准备运行脚本并完成 Cyprus 1 合约链接。确保在**向 Cyprus 1 合约发送交易时**传递 `--network cyprus1` 标志。

    ```bash
    npx hardhat run scripts/addApprovedAddresses.js --network cyprus1

````

    脚本应该输出类似这样的内容：

    ```bash
    Transaction sent: 0x00499178c3f0046b4d44a57a966f9e224759c1b3158af984fcb5a1432b16ee8e
    Transaction mined with hash: 0x00499178c3f0046b4d44a57a966f9e224759c1b3158af984fcb5a1432b16ee8e
````

    我们现在已经将我们的 Cyprus 1 合约链接到我们的 Cyprus 2 合约，但我们还没有完成。

    要完成链接这两个姊妹合约，我们需要向 Cyprus 2 合约发送完全相同的交易数据。在 `addApprovedAddresses.js` 脚本中，将 `contractAddress` 变量更改为**我们的 Cyprus 2 合约地址**：

    ```javascript
    const contractAddress = '0x0172F38EC31f58B1419E2CcE2B05B095625218ea'

````

    最后，通过使用 `--network cyprus2` 标志运行脚本向我们的 Cyprus 2 代币发送链接交易：

    ```bash
    Transaction sent: 0x018e8dea20b73089b51e6b3d2b3abd8a9e8ca63e06be20375cf721e13aabd590
    Transaction mined with hash: 0x018e8dea20b73089b51e6b3d2b3abd8a9e8ca63e06be20375cf721e13aabd590
````

  </Step>
</Steps>

一旦第二笔交易被确认，我们的两个 QRC721 合约就已经成功跨链链接了。铸造代币后，您现在可以在没有桥接或外部服务的情况下将您的 NFT 从 Cyprus 1 发送到 Cyprus 2！

这个部署和链接过程可以通过将合约部署到所需的链并使用 `addApprovedAddresses` 方法链接它们来在 Quai Network 内的任意数量的链上重复。您现在拥有在 Quai Network 内所有区域链上部署和链接合约的工具。

<Note>
	相同的部署和链接方法可用于任何其他基于 SolidityX 的具有跨链逻辑的合约，包括 [QRC-20 代币](https://github.com/dominant-strategies/SolidityX-Contracts/blob/main/QRC20X.sol)。
</Note>