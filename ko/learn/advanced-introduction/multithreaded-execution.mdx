---
title: 멀티스레드 실행
description: Quai 네트워크가 트랜잭션을 병렬로 처리하는 방법을 알아보세요.
---

## 싱글코어에서 멀티코어 블록체인으로

컴퓨팅 초기에는 프로세서가 한 번에 하나의 작업만 처리할 수 있었습니다. 모든 것이 줄을 서서 기다려야 했고, 이로 인해 성능을 제한하는 병목현상이 발생했습니다. 멀티코어 CPU의 발명은 모든 것을 바꿔놓았습니다 - 갑자기 컴퓨터들이 여러 작업을 동시에 처리할 수 있게 되었고, 엄청난 성능 향상을 가능하게 했습니다. Quai는 이와 동일한 혁명을 블록체인 기술에 가져옵니다.

전통적인 블록체인들은 싱글코어 프로세서처럼 작동합니다. 모든 트랜잭션은 하나의 처리 채널을 통해 줄을 서서 차례를 기다려야 합니다. 바쁜 시간대에는 이것이 대규모 혼잡을 만듭니다 - 마치 도시 전체의 교통량을 단일 차선으로 유도하려는 것과 같습니다. 사용자들은 높은 수수료, 긴 대기 시간, 그리고 실패한 트랜잭션을 경험합니다.

**멀티코어 솔루션:**
Quai의 멀티스레드 실행은 여러 블록체인 스레드가 트랜잭션을 병렬로 처리할 수 있게 하며, 이는 현대 CPU가 여러 작업을 동시에 처리하는 것과 같습니다. 각 존 체인은 독립적인 실행 스레드로 작동하며, 더 넓은 네트워크와 동기화를 유지하면서 자체 트랜잭션을 처리합니다.

**Quai가 이를 달성하는 방법:**
돌파구는 전통적인 블록체인이 긴밀하게 결합하는 두 개념을 분리하는 것에서 나옵니다: 로컬 일관성(존의 모든 사람이 동의)과 글로벌 합의(전체 네트워크가 동의). Quai에서는:
- 존들이 자신의 트랜잭션에 대해 즉시 로컬 합의를 달성
- 글로벌 합의는 블록들이 계층구조에 짜여지면서 점진적으로 발생
- 사용자들은 네트워크 전체 보안을 유지하면서 빠른 확인을 받음

이 아키텍처는 진정한 병렬 처리를 가능하게 합니다 - 여러 존들이 서로를 기다리지 않고 동시에 블록을 생성할 수 있어, 전체 처리량을 극적으로 증가시킵니다.

<Frame>
	<img src='/images/BlockchainVisualization.webp' />
</Frame>

## 일관성과 글로벌 합의의 분리

Quai의 돌파구를 이해하려면, 전통적인 블록체인이 혼동하는 두 개념을 구별해야 합니다. 일관성은 모든 노드가 동일한 데이터를 갖는다는 뜻입니다 - 마치 모든 사람이 공유 문서의 동일한 버전을 갖는 것과 같습니다. 합의는 모든 사람이 그 버전이 올바르다고 동의한다는 뜻입니다 - 마치 모든 사람이 그 문서에 서명하는 것과 같습니다.

전통적인 블록체인들은 이것들이 함께 일어나도록 강제합니다. 문서를 저장하려고 할 때마다 회사의 모든 사람이 검토하고 승인하기를 기다려야 한다고 상상해보세요. 그것이 비트코인과 이더리움이 작동하는 방식입니다 - 모든 사람이 동의할 때까지는 아무것도 일관성을 가질 수 없어, 대규모 지연을 만듭니다.

**전통적인 문제:**
싱글스레드 블록체인에서 이 결합은 악순환을 만듭니다:
1. 새로운 블록이 제안됨
2. 데이터가 일관성을 갖기 전에 네트워크가 합의에 도달해야 함
3. 합의 과정 중에 노드들이 데이터를 동기화하려고 분주함
4. 지연이 각 단계에서 복합적으로 누적됨
5. 결과: 느린 확인과 제한된 처리량

**Quai의 혁신:**
Quai는 계층적 구조를 통해 이러한 프로세스들을 분리합니다:
- **로컬 일관성**: 존들이 자신의 트랜잭션에 즉시 동의할 수 있음
- **점진적 합의**: 동의가 로컬에서 지역으로, 그리고 글로벌로 확장됨
- **대기 없음**: 글로벌 합의가 백그라운드에서 진행되는 동안 사용자들이 즉시 로컬 확인을 받음

**보안 보장:**
이 분리는 보안을 타협하지 않습니다. Quai는 원자적 롤백을 유지합니다 - 글로벌 합의가 존의 상태를 거부하는 경우(극히 드문 일), 모든 영향을 받는 트랜잭션들이 함께 되돌려집니다. 이는 대규모 성능 향상을 가능하게 하면서 이중 지출의 가능성을 방지합니다.

결과는 트랜잭션이 몇 초 안에 로컬에서 처리되고 확인될 수 있으면서도, 글로벌 합의의 보안 보장을 유지하는 시스템입니다. 글로벌 상태와 동기화가 보장되는 빠른 로컬 캐시를 갖는 것과 같습니다.

## 분할된 상태: 분할 정복

전통적인 블록체인들은 모든 노드가 모든 것을 저장하도록 요구합니다 - 모든 트랜잭션, 모든 계정 잔액, 모든 스마트 컨트랙트. 이는 모든 도서관 지점이 전체 도서관 시스템의 모든 책을 보관하도록 요구하는 것과 같습니다. 이는 대규모 비효율성을 만들고 확장성을 제한합니다. Quai의 분할된 상태 아키텍처는 이 패러다임을 완전히 바꿉니다.

각 존은 글로벌 상태의 자신의 슬라이스만 유지합니다. 회사의 전문 부서들과 같이 생각해보세요 - 회계부는 엔지니어링 파일을 저장할 필요가 없고, 그 반대도 마찬가지입니다. 이 전문화는 필요할 때 조정할 수 있는 능력을 유지하면서 요구사항을 극적으로 줄입니다.

**저장 효율성:**
N개 존이 있는 네트워크에서:
- 전통적 접근: 모든 노드가 글로벌 상태의 100%를 저장
- Quai 접근: 각 존 노드가 글로벌 상태의 ~1/N만 저장
- 슬라이스 노드: P개 존을 실행하도록 선택할 수 있어, 총 상태의 P/N만 저장

이는 노드 운영자가 극적으로 낮은 하드웨어 요구사항으로 네트워크에 참여할 수 있게 하여, 탈중앙화를 개선합니다.

**대역폭 최적화:**
분할된 상태는 또한 네트워크 효율성을 혁신적으로 개선합니다:
- **로컬 트랜잭션**: 자신의 존 내에 머물러, 글로벌 브로드캐스트가 필요 없음
- **스마트 라우팅**: 데이터가 필요한 곳으로만 이동
- **혼잡 감소**: 각 존이 독립적으로 자신의 트래픽을 처리

회사의 모든 이메일이 모든 직원에게 보내져야 한다고 상상해보세요. 그것이 전통적인 블록체인이 작동하는 방식입니다. Quai의 접근법은 부서별 메일링 리스트를 갖는 것과 같습니다 - 메시지가 관련이 있는 곳으로만 갑니다.

**빠른 일관성:**
분할된 접근법은 번개같이 빠른 로컬 일관성을 가능하게 합니다:
1. 존 트랜잭션들이 즉시 로컬 합의를 달성
2. 해시 링크된 참조들이 점진적으로 합의 범위를 확장
3. 글로벌 합의가 로컬 운영을 방해하지 않고 발생
4. 사용자들이 최종적인 글로벌 완결성과 함께 즉시 확인을 경험

이 아키텍처는 모놀리식 블록체인 설계를 괴롭히는 병목현상을 제거하여 Quai가 50,000+ TPS를 처리할 수 있게 합니다.

## 병렬 처리: 성능 승수

멀티스레드 실행의 진정한 힘은 실제로 보았을 때 명백해집니다. 전통적인 블록체인들이 트랜잭션을 순차적으로 - 단일 라인에서 하나씩 차례로 - 처리하는 반면, Quai는 여러 존에서 병렬로 처리합니다. 상점의 단일 계산원과 동시에 운영되는 여러 계산대의 차이와 같습니다.

**기술적 구현:**
Quai는 각 존에 자체 독립적인 쓰기 잠금과 계산 리소스를 제공하여 진정한 병렬 처리를 달성합니다. 이는 다음을 의미합니다:
- 존 A가 DeFi 스왑을 처리할 수 있음
- 존 B가 NFT 민팅을 처리하는 동안
- 존 C가 게임 트랜잭션을 실행하는 동안
- 모든 것이 간섭 없이 동시에 발생

**비동기 블록 생성:**
각 존은 다른 존들을 기다리지 않고 자체 스케줄에 따라 블록을 생성합니다:
- 글로벌 동기화 지연 없음
- 존 간 병목현상 없음
- 계산 리소스의 최대 활용

**50,000 TPS 현실:**
이 병렬 아키텍처는 Quai가 네트워크 전체에서 초당 50,000개 이상의 트랜잭션을 달성할 수 있게 합니다. 하지만 보안이나 탈중앙화를 희생하는 다른 고TPS 주장들과 달리, Quai는 다음을 유지합니다:
- [PoEM 합의](/ko/learn/advanced-introduction/poem/poem)를 통한 완전한 원자성
- 모든 존에서의 완전한 보안
- 접근 가능한 노드 요구사항으로 진정한 탈중앙화

**조정된 독립성:**
시스템의 천재적인 점은 존들이 성능을 위해 독립적으로 작동하면서도 보안을 위해 조정된 상태로 남는다는 것입니다. 어떤 문제가 발생하면(극히 드문 일), PoEM 합의는 모든 영향을 받는 존들이 함께 롤백되도록 보장하여, 전체 네트워크에서 일관성을 유지합니다.

이것이 최고의 멀티스레드 블록체인 실행입니다 - 통합된 합의의 보안과 함께 병렬 처리의 성능을 제공합니다.